/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//***************************************************************

JEP - Java Math Expression Parser 2.3.0
      October 3 2004
      (c) Copyright 2004, Nathan Funk and Richard Morris
      See LICENSE.txt for license information.

This file contains the grammar from which the parser is
generated. The parser generation tools being used are JavaCC
and its component JJTree. JJTree processes the .jjt file and
generates the .jj file. This file is then used be JavaCC to
generate the final java classes.

Knowledge of parser generation is definitely beneficial if you
are planning to make changes to this file. Although many parts
are self explanatory, it is helpful to know how the grammar is
handled by JJTree and JavaCC.

You can follow the structure of the grammar by starting in the
line which reads "ASTStart Start() #Start : {}". From there you
will be able to trace the same path the parser follows when
parsing an expression.

The concept of precedence is very important. Since this is a
recursive descent parser, it is easy to see which operators have
higher order of precedence. The following table outlines the
order incorporated in this grammar.

Order of precedence (from lowest to highest):

   ||               or  (logical)
   &&               and (logical)
   ==  !=           equal, not equal
   <   >   <=  >=   less, greater, less or equal, greater or equal
   +   -            addition, subtraction
   *   /   %        multiplication, division, modulus
   !   +   -        not, unary +/-
   ^                power

The order of precedence is greatly inspired by the operator
precedence of the C language. See "The C Programming Language"
Kernighan & Richie 2nd Ed p.53. Java also uses a very similar
precedence. Note that the '^' operator is used for bitwise 
exclusive OR in Java and C, but represents the power operator
in this grammar.

***************************************************************/



/***************************************************************
OPTIONS
***************************************************************/
options {
	JAVA_UNICODE_ESCAPE = true;
	             
	               
	                                     
	                         
//	NODE_PACKAGE = "org.nfunk.jep.parser";
//	BUILD_NODE_FILES=false;
	STATIC = false;
//	DEBUG_TOKEN_MANAGER = true;
}


/***************************************************************
PARSER BEGIN
***************************************************************/

PARSER_BEGIN(Parser)
package org.nfunk.jep;

import org.nfunk.jep.function.PostfixMathCommandI;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
	private JEP jep;
	private SymbolTable symTab;
	private OperatorSet opSet;
	private int initialTokenManagerState = DEFAULT;
	
	public Node parseStream(java.io.Reader stream, JEP jep_in) throws ParseException {
		restart(stream,jep_in);
		// Parse the expression, and return the enable_tracing();
		Node node = Start();
		if(node == null) throw new ParseException(JEP.getMessage("JEP.ERR.NOEXPR")); // modified by lm
		return node.jjtGetChild(0);
	}

	/**
	 * Restart the parse with the given stream.
	 * @since 2.3.0 beta 1
	 */
	public void restart(java.io.Reader stream, JEP jep_in) {
		ReInit(stream);
   		this.token_source.SwitchTo(initialTokenManagerState);
		jep = jep_in;
		symTab = jep.getSymbolTable();
		opSet = jep.getOperatorSet();
	}

	/**
	 * Continue parsing without re-initialising stream.
	 * Allows reentrancy of parser so that strings like
	 * "x=1; y=2; z=3;" can be parsed.
	 * When a semi colon is encountered parsing finishes leaving the rest of the string unparsed.
	 * Parsing can be resumed from the current position by using this method.
	 * For example
	 * <pre>
	 * XJep j = new XJep();
	 * Parser parse = j.getParse();
	 * StringReader sr = new StringReader("x=1; y=2; z=3;");
	 * parse.restart(sr,j);
	 * Node node;
	 * try {
	 * while((node = j.continueParse())!=null) {
	 *    j.println(node);
	 * } }catch(ParseException e) {}
	 * </pre>
	 */
	public Node continueParse() throws ParseException {
		ASTStart node = Start();
		if(node==null) return null;
		return node.jjtGetChild(0);
	}

	private void addToErrorList(String errorStr) {
		jep.errorList.addElement(errorStr);		
	}

	/**
	 * Sets the initial state that the token manager is in.
	 * Can be used to change how x.x is interpreted, either as a single
	 * identifier (DEFAULT) or as x <DOT> x (NO_DOT_IN_IDENTIFIERS)
	 * @param state the state to be in. Currently the only legal values are DEFAULT and NO_DOT_IN_IDENTIFIER
	 */
	public void setInitialTokenManagerState(int state) {
		initialTokenManagerState = state;
	}

	/**
	 * Translate all escape sequences to characters. Inspired by Rob Millar's
	 * unescape() method in rcm.util.Str fron the Web Sphinx project.
	 *
	 * @param inputStr String containing escape characters.
	 * @return String with all escape sequences replaced.
	 */
	private String replaceEscape(String inputStr) {
		int len = inputStr.length();
		int p = 0;
		int i;
		String metachars = "tnrbf\\\"'";
		String chars = "\t\n\r\b\f\\\"'";
		StringBuffer output = new StringBuffer();
		while((i = inputStr.indexOf('\\', p)) != -1) {
			output.append(inputStr.substring(p, i));
			if(i+1 == len) break;
			// find metacharacter
			char metac = inputStr.charAt(i+1);
			// find the index of the metac
			int k = metachars.indexOf(metac);
			if(k == -1) {
				// didn't find the metachar, leave sequence as found.
				// This code should be unreachable if the parser
				// is functioning properly because strings containing
				// unknown escape characters should not be accepted.
				output.append('\\');
				output.append(metac);
			} else {
				// its corresponding true char
				output.append(chars.charAt(k));   
			}
			// skip over both escape character & metacharacter
			p = i + 2;
		}
		// add the end of the input string to the output
		if(p < len) output.append(inputStr.substring(p));
		return output.toString();
	}
}

PARSER_END(Parser)

/***************************************************************
SKIP
***************************************************************/

<*> SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

<*> TOKEN : /* LITERALS */
{
	< INTEGER_LITERAL:
		<DECIMAL_LITERAL>
	>
  |
	< #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
  |
	< FLOATING_POINT_LITERAL:
		(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
	>
  |
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
  |
	< STRING_LITERAL:
		"\""
		( (~["\"","\\","\n","\r"])
		| ("\\" ["n","t","b","r","f","\\","'","\""]	)
		)*
		"\""
	>
}

/* IDENTIFIERS 
	
	Letters before version 2.22
	< #LETTER: ["_","a"-"z","A"-"Z"] >

	In Ver 2.3.0.1 presence of . in an identifier is switchable.
	In the DEFAULT lexical state identifiers can contain a .
	In the NO_DOT_IN_IDENTIFIERS state identifiers cannot contain a .
	the state can be set by using
	Parser.setInitialTokenManagerState
*/

<DEFAULT> TOKEN:
{
	<IDENTIFIER1: <LETTER1>(<LETTER1>|<DIGIT1>|".")*>
  |
	< #LETTER1:
	[
		"$",           // $
		"A"-"Z",  // A - Z
		"_",           // _
		"a"-"z",  // a - z
		"\u00c0"-"\u00d6",  // Upper case symbols of Latin-1 Supplement
		"\u00d8"-"\u00f6",  // Lower case symbols of Latin-1 Supplement
		"\u00f8"-"\u00ff",  // More lower case symbols of Latin-1 Supplement
		"\u0100"-"\u1fff",  // Many languages (including Greek)
		"\u3040"-"\u318f",  // Hiragana, Katakana, Bopomofo, Hangul Compatibility Jamo
		"\u3300"-"\u337f",  // CJK Compatibility
		"\u3400"-"\u3d2d",  // CJK Unified Ideographs Extension A
		"\u4e00"-"\u9fff",  // CJK Unified Ideographs
		"\uf900"-"\ufaff"   // CJK Compatibility Ideographs
	]
	>	
  |
	< #DIGIT1: ["0"-"9"] >
}

<NO_DOT_IN_IDENTIFIERS> TOKEN:
{
	<IDENTIFIER2: <LETTER2>(<LETTER2>|<DIGIT2>)*>
  |
	< #LETTER2:
	[
		"$",           // $
		"A"-"Z",  // A - Z
		"_",           // _
		"a"-"z",  // a - z
		"\u00c0"-"\u00d6",  // Upper case symbols of Latin-1 Supplement
		"\u00d8"-"\u00f6",  // Lower case symbols of Latin-1 Supplement
		"\u00f8"-"\u00ff",  // More lower case symbols of Latin-1 Supplement
		"\u0100"-"\u1fff",  // Many languages (including Greek)
		"\u3040"-"\u318f",  // Hiragana, Katakana, Bopomofo, Hangul Compatibility Jamo
		"\u3300"-"\u337f",  // CJK Compatibility
		"\u3400"-"\u3d2d",  // CJK Unified Ideographs Extension A
		"\u4e00"-"\u9fff",  // CJK Unified Ideographs
		"\uf900"-"\ufaff"   // CJK Compatibility Ideographs
	]
	>	
  |
	< #DIGIT2: ["0"-"9"] >
}

/* OPERATORS */
<*> TOKEN:
{
    < ASSIGN: "=">  // rjm
  | < SEMI:	";"  >	// rjm
  |	< COMMA:","  >	// rjm
  |	< GT:   ">"  >
  |	< LT:   "<"  >
  |	< EQ:   "==" >
  |	< LE:   "<=" >
  |	< GE:   ">=" >
  |	< NE:   "!=" >
  |	< AND:  "&&" >
  |	< OR:   "||" >
  |	< PLUS: "+"  >
  |	< MINUS:"-"  >
  |	< MUL:  "*"  >
  |	< DOT:  "."  >	// rjm
  |	< DIV:  "/"  >
  |	< BDIV: "\\" >  // lm
  |	< PIPE: "|"  >  // lm
  |	< MOD:  "%"  >
  |	< NOT:  "!"  >
  |	< POWER:"^"  >
  |	< CROSS:"^^" >  // rjm
  |	< LSQ:	"["  >	// rjm
  |	< RSQ:	"]"  >	// rjm
  |	< LRND:	"("  >	// rjm
  |	< RRND:	")"  >	// rjm
  |	< COLON:":"  >	// lm
  |	< SHARP: "#" >	// lm
  |	< SSHARP:"##">  // lm
  |	< AT: "@"    >  // lm
  |	< X1: "&"    >  // lm
  |	< X2: "\""   >  // lm
  |	< QUOTE: "\'">  // lm
  |	< LCURLY: "{">  // lm
  |	< RCURLY: "}">  // lm
  |	< BLANK: "`" >	// lm (a metacharacter, to allow formatting)
  |	< NEWLINE:"~">	// lm (a metacharacter, to allow formatting)
}


/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	Expression()
		(			<SEMI> Expression()
		)*
		<EOF>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ // modified by lm
			{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Expression() : {}
{
	AndExpression()
		(/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( <OR> AndExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{ jjtn001.setOperator(opSet.getOr()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
		)*
}


void AndExpression() : {}
{
	EqualExpression()
		(/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( <AND> EqualExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{ jjtn001.setOperator(opSet.getAnd()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
		)*
}


void EqualExpression() : {}
{
	RelationalExpression()
		(/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( <NE> RelationalExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{ jjtn001.setOperator(opSet.getNE()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/
			( <EQ> RelationalExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                  jjtc002 = false;
                                }
/*@egen*/
				{ jjtn002.setOperator(opSet.getEQ()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002,  2);
                          }
                        }
/*@egen*/            
		)*
}


void RelationalExpression() : {}
{
	AdditiveExpression()
		(/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( <LT> AdditiveExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{ jjtn001.setOperator(opSet.getLT()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/
			( <GT> AdditiveExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                  jjtc002 = false;
                                }
/*@egen*/
				{ jjtn002.setOperator(opSet.getGT()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/
			( <LE> AdditiveExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn003,  2);
                                  jjtc003 = false;
                                }
/*@egen*/
				{ jjtn003.setOperator(opSet.getLE()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                        }
                        try {
/*@egen*/
			( <GE> AdditiveExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn004,  2);
                                  jjtc004 = false;
                                }
/*@egen*/
				{ jjtn004.setOperator(opSet.getGE()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004,  2);
                          }
                        }
/*@egen*/            
		)*
}


void AdditiveExpression() : {}
{
	MultiplicativeExpression()
		(/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( <PLUS> MultiplicativeExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{ jjtn001.setOperator(opSet.getAdd()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/
			( <MINUS> MultiplicativeExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                  jjtc002 = false;
                                }
/*@egen*/
				{ jjtn002.setOperator(opSet.getSubtract()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002,  2);
                          }
                        }
/*@egen*/            
		)*
}


void MultiplicativeExpression() : { Operator op = null; Operator op2 = null; }
{
	UnaryExpression()
		(/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( PowerExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{
					if(!jep.implicitMul) throw new ParseException(JEP.getMessage("JEP.ERR.IMPL_MULT")); // modified by lm
					jjtn001.setOperator(opSet.getMultiply());
				}
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/
			( <MUL> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                  jjtc002 = false;
                                }
/*@egen*/
				{ jjtn002.setOperator(opSet.getMultiply()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/
			( <DOT> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn003,  2);
                                  jjtc003 = false;
                                }
/*@egen*/
				{ jjtn003.setOperator(opSet.getDot()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                        }
                        try {
/*@egen*/
			( <CROSS> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn004,  2);
                                  jjtc004 = false;
                                }
/*@egen*/
				{ jjtn004.setOperator(opSet.getCross()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn005 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc005 = true;
                          jjtree.openNodeScope(jjtn005);
                        }
                        try {
/*@egen*/
			( <DIV> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn005,  2);
                                  jjtc005 = false;
                                }
/*@egen*/
				{ jjtn005.setOperator(opSet.getDivide()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte005) {
                          if (jjtc005) {
                            jjtree.clearNodeScope(jjtn005);
                            jjtc005 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte005 instanceof RuntimeException) {
                            throw (RuntimeException)jjte005;
                          }
                          if (jjte005 instanceof ParseException) {
                            throw (ParseException)jjte005;
                          }
                          throw (Error)jjte005;
                        } finally {
                          if (jjtc005) {
                            jjtree.closeNodeScope(jjtn005,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn006 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc006 = true;
                          jjtree.openNodeScope(jjtn006);
                        }
                        try {
/*@egen*/
			( <MOD> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn006,  2);
                                  jjtc006 = false;
                                }
/*@egen*/
				{ jjtn006.setOperator(opSet.getMod()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte006) {
                          if (jjtc006) {
                            jjtree.clearNodeScope(jjtn006);
                            jjtc006 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte006 instanceof RuntimeException) {
                            throw (RuntimeException)jjte006;
                          }
                          if (jjte006 instanceof ParseException) {
                            throw (ParseException)jjte006;
                          }
                          throw (Error)jjte006;
                        } finally {
                          if (jjtc006) {
                            jjtree.closeNodeScope(jjtn006,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn007 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                        }
                        try {
/*@egen*/
			( <SHARP> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn007,  2);
                                  jjtc007 = false;
                                }
/*@egen*/	// added by lm
				{ jjtn007.setOperator(opSet.getConcatenate()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007,  2);
                          }
                        }
/*@egen*/            
			|/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn008 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                        }
                        try {
/*@egen*/
			( <SSHARP> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn008,  2);
                                  jjtc008 = false;
                                }
/*@egen*/	// added by lm
				{ jjtn008.setOperator(opSet.getDecatenate()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008,  2);
                          }
                        }
/*@egen*/            
		)*
}


void UnaryExpression() : { Operator op = null; Object dim = null; }
{
	LOOKAHEAD(<PLUS> UnaryExpression())
	( <PLUS> UnaryExpression() )
	|
	LOOKAHEAD(<MINUS> UnaryExpression())/*@bgen(jjtree) #FunNode( 1) */
        {
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	( <MINUS> UnaryExpression()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001,  1);
                  jjtc001 = false;
                }
/*@egen*/
		{ jjtn001.setOperator(opSet.getUMinus()); }
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/            
	|/*@bgen(jjtree) #FunNode( 1) */
        {
          ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	( <NOT> UnaryExpression()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002,  1);
                  jjtc002 = false;
                }
/*@egen*/
		{ jjtn002.setOperator(opSet.getNot()); }
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  1);
          }
        }
/*@egen*/            
	|/*@bgen(jjtree) #FunNode( 1) */
        {
          ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	( <AT> UnaryExpression()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn003,  1);
                  jjtc003 = false;
                }
/*@egen*/			// added by LM: monadic prefix operator
		{ jjtn003.setOperator(opSet.getSize()); }
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  1);
          }
        }
/*@egen*/            
	|
	LOOKAHEAD(ModifiableOperator() <DIV> <LSQ> RealConstant() <RSQ> UnaryExpression())/*@bgen(jjtree) #FunNode( 3) */
        {
          ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*/
	( op = ModifiableOperator()			// added by LM: APL-style reduction-with-dim operator
	  <DIV> <LSQ> dim = RealConstant() <RSQ> 
		{
			jjtn004.setOperator(op);
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("/");
			jjtree.pushNode(leftarg);
			ASTConstant leftarg2 = new ASTConstant(JJTCONSTANT);
			leftarg2.setValue(dim);
			jjtree.pushNode(leftarg2);
		} UnaryExpression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte004) {
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte004 instanceof RuntimeException) {
            throw (RuntimeException)jjte004;
          }
          if (jjte004 instanceof ParseException) {
            throw (ParseException)jjte004;
          }
          throw (Error)jjte004;
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  3);
          }
        }
/*@egen*/            
	|
	LOOKAHEAD(ModifiableOperator() <PIPE> <LSQ> RealConstant() <RSQ> UnaryExpression())/*@bgen(jjtree) #FunNode( 3) */
        {
          ASTFunNode jjtn005 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*/
	( op = ModifiableOperator()			// added by LM: APL-style pair-scan-with-dim operator
	  <PIPE> <LSQ> dim = RealConstant() <RSQ> 
		{
			jjtn005.setOperator(op);
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("|");
			jjtree.pushNode(leftarg);
			ASTConstant leftarg2 = new ASTConstant(JJTCONSTANT);
			leftarg2.setValue(dim);
			jjtree.pushNode(leftarg2);
		} UnaryExpression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte005) {
          if (jjtc005) {
            jjtree.clearNodeScope(jjtn005);
            jjtc005 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte005 instanceof RuntimeException) {
            throw (RuntimeException)jjte005;
          }
          if (jjte005 instanceof ParseException) {
            throw (ParseException)jjte005;
          }
          throw (Error)jjte005;
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005,  3);
          }
        }
/*@egen*/            
	|
	LOOKAHEAD(ModifiableOperator() <BDIV> <LSQ> RealConstant() <RSQ> UnaryExpression())/*@bgen(jjtree) #FunNode( 3) */
        {
          ASTFunNode jjtn006 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*/
	( op = ModifiableOperator()			// added by LM: APL-style scan-with-dim operator
	  <BDIV> <LSQ> dim = RealConstant() <RSQ> 
		{
			jjtn006.setOperator(op);
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("\\");
			jjtree.pushNode(leftarg);
			ASTConstant leftarg2 = new ASTConstant(JJTCONSTANT);
			leftarg2.setValue(dim);
			jjtree.pushNode(leftarg2);
		} UnaryExpression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            throw (RuntimeException)jjte006;
          }
          if (jjte006 instanceof ParseException) {
            throw (ParseException)jjte006;
          }
          throw (Error)jjte006;
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006,  3);
          }
        }
/*@egen*/            
	|
	LOOKAHEAD(ModifiableOperator() <DIV> UnaryExpression())/*@bgen(jjtree) #FunNode( 2) */
        {
          ASTFunNode jjtn007 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*/
	( op = ModifiableOperator()			// added by LM: APL-style reduction operator
		{
			jjtn007.setOperator(op);
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("/");
			jjtree.pushNode(leftarg);
		} <DIV> UnaryExpression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte007) {
          if (jjtc007) {
            jjtree.clearNodeScope(jjtn007);
            jjtc007 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte007 instanceof RuntimeException) {
            throw (RuntimeException)jjte007;
          }
          if (jjte007 instanceof ParseException) {
            throw (ParseException)jjte007;
          }
          throw (Error)jjte007;
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007,  2);
          }
        }
/*@egen*/            
	|
	LOOKAHEAD(ModifiableOperator() <PIPE> UnaryExpression())/*@bgen(jjtree) #FunNode( 2) */
        {
          ASTFunNode jjtn008 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc008 = true;
          jjtree.openNodeScope(jjtn008);
        }
        try {
/*@egen*/
	( op = ModifiableOperator()			// added by LM: APL-style pair-scan operator
		{
			jjtn008.setOperator(op);
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("|");
			jjtree.pushNode(leftarg);
		} <PIPE> UnaryExpression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte008) {
          if (jjtc008) {
            jjtree.clearNodeScope(jjtn008);
            jjtc008 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte008 instanceof RuntimeException) {
            throw (RuntimeException)jjte008;
          }
          if (jjte008 instanceof ParseException) {
            throw (ParseException)jjte008;
          }
          throw (Error)jjte008;
        } finally {
          if (jjtc008) {
            jjtree.closeNodeScope(jjtn008,  2);
          }
        }
/*@egen*/            
	|
	LOOKAHEAD(ModifiableOperator() <BDIV> UnaryExpression())/*@bgen(jjtree) #FunNode( 2) */
        {
          ASTFunNode jjtn009 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc009 = true;
          jjtree.openNodeScope(jjtn009);
        }
        try {
/*@egen*/
	( op = ModifiableOperator()			// added by LM: APL-style scan operator
		{
			jjtn009.setOperator(op);
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("\\");
			jjtree.pushNode(leftarg);
		} <BDIV> UnaryExpression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte009) {
          if (jjtc009) {
            jjtree.clearNodeScope(jjtn009);
            jjtc009 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte009 instanceof RuntimeException) {
            throw (RuntimeException)jjte009;
          }
          if (jjte009 instanceof ParseException) {
            throw (ParseException)jjte009;
          }
          throw (Error)jjte009;
        } finally {
          if (jjtc009) {
            jjtree.closeNodeScope(jjtn009,  2);
          }
        }
/*@egen*/            
	|
	PowerExpression()
}


Operator ModifiableOperator() : {}		// added by LM: for APL-style operators
{
	( <PLUS>
		{ return opSet.getAdd(); }
	)
	|
	( <MUL>
		{ return opSet.getMultiply(); }
	)
	|
	( <MINUS>
		{ return opSet.getSubtract(); }
	)
	|
	( <DIV>
		{ return opSet.getDivide(); }
	)
	|
	( <MOD>
		{ return opSet.getMod(); }
	)
	|
	( <POWER>
		{ return opSet.getPower(); }
	)
	|
	( <AND>
		{ return opSet.getAnd(); }
	)
	|
	( <OR>
		{ return opSet.getOr(); }
	)
	|
	( <GT>
		{ return opSet.getGT(); }
	)
	|
	( <LT>
		{ return opSet.getLT(); }
	)
		|
	( <EQ>
		{ return opSet.getEQ(); }
	)
		|
	( <LE>
		{ return opSet.getLE(); }
	)
		|
	( <GE>
		{ return opSet.getGE(); }
	)
		|
	( <NE>
		{ return opSet.getNE(); }
	)
}


void PowerExpression() : {}
{
	UnaryExpressionNotPlusMinus()
		[/*@bgen(jjtree) #FunNode( 2) */
                        {
                          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			( <POWER> UnaryExpression()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{ jjtn001.setOperator(opSet.getPower()); }
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/            
		]
}


void UnaryExpressionNotPlusMinus() : {}
{
	AnyConstant()
	|
	( LOOKAHEAD({
		(
			(getToken(1).kind == IDENTIFIER1 || getToken(1).kind == IDENTIFIER2)
				&&		// modified by lm, to deal with custom functions
			(jep.funTab.containsKey(getToken(1).image) || (jep.symTab.containsKey(getToken(1).image) && getToken(1).image.startsWith("_") && !getToken(1).image.startsWith("__")))
		)
				})
		Function()
		|
		Variable()
	)
	|
	<LRND> Expression() <RRND>
	|
	ListExpression()
	|
	DefinedExpression()
}


void ListExpression()          : {/*@bgen(jjtree) FunNode */
  ASTFunNode jjtn000 = new ASTFunNode(JJTFUNNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 	// modified by lm, to deal with [x:y] and [x:y:z] lists
{/*@bgen(jjtree) FunNode */
        try {
/*@egen*/
	LOOKAHEAD(50)
	( <LSQ> [ Expression() ( <COMMA> Expression() )* ] <RSQ>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/	// modified by lm, to allow empty ([]) lists
		{ jjtn000.setOperator(opSet.getList()); }
	)
	|
	LOOKAHEAD(50)
	( <LSQ> Expression() <COLON> Expression() <COLON> Expression() <RSQ>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ jjtn000.setOperator(opSet.getList2()); }
	)
	|
	LOOKAHEAD(50)
	( <LSQ> Expression() <COLON> Expression() <RSQ>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ jjtn000.setOperator(opSet.getList2()); }
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void DefinedExpression()          : {/*@bgen(jjtree) FunNode */
  ASTFunNode jjtn000 = new ASTFunNode(JJTFUNNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 	// modified by lm, to deal with {expr} lists
{/*@bgen(jjtree) FunNode */
        try {
/*@egen*/
	( <LCURLY> Expression() <RCURLY>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ jjtn000.setOperator(opSet.getDefExpr()); }
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Variable() : { String identString = ""; }	 	// modified by lm, to deal with list selectors
{
	LOOKAHEAD(50)
	( identString = Identifier()
		{
			if(!symTab.containsKey(identString)) {
				addToErrorList(JEP.getMessage("JEP.ERR.UNREC_LIST") + ": \"" + identString +"\""); // modified by lm
			}
		}
		<LSQ> ListSelector(identString) <RSQ>
	)
	|/*@bgen(jjtree) VarNode */
        {
          ASTVarNode jjtn001 = new ASTVarNode(JJTVARNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	( identString = Identifier()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/
		{
			if(symTab.containsKey(identString)) {
				jjtn001.setVar(symTab.getVar(identString));
			} else {
				if(jep.allowUndeclared) {
					jjtn001.setVar(symTab.makeVarIfNeeded(identString));
				} else {
					addToErrorList(JEP.getMessage("JEP.ERR.UNREC_VAR") + ": \"" + identString +"\""); // modified by lm
				}
			}
		}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/         
}


void ListSelector(String listName) : {}	 	// added by lm: Python-style list selectors
{/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(					// list[index1,index2,...]
		{
			jjtn001.setFunction("get", (PostfixMathCommandI)jep.funTab.get("get"));
			ASTVarNode leftarg = new ASTVarNode(JJTVARNODE);
			leftarg.setVar(symTab.getVar(listName));
			jjtree.pushNode(leftarg);
		}
	Expression() ( <COMMA> Expression() )*
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/         
}


void Function() : { int reqArguments = 0; String identString = ""; Object dim = null; }
{
	LOOKAHEAD(20)/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	( identString = Identifier()
		{
			if(jep.funTab.containsKey(identString)) {
				reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
				jjtn001.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
			} else if(jep.symTab.containsKey(identString)) { // added by lm: custom (user-defined) function
				reqArguments = -1;
				jjtn001.setFunction("exec", (PostfixMathCommandI)jep.funTab.get("exec"));
				ASTVarNode leftarg = new ASTVarNode(JJTVARNODE);
				leftarg.setVar(symTab.getVar(identString));
				jjtree.pushNode(leftarg);
			} else {
				addToErrorList(JEP.getMessage("JEP.ERR.UNREC_FUN") + ": \"" + identString + "\""); // modified by lm
			}
		}
		<LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/         
	|
	LOOKAHEAD(Identifier() <DIV> <LSQ> RealConstant() <RSQ> UnaryExpression())/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	( identString = Identifier()			// added by LM: APL-style reduction-with-dim operator
	  <DIV> <LSQ> dim = RealConstant() <RSQ> 
		{
			reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
			jjtn002.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("/");
			jjtree.pushNode(leftarg);
			ASTConstant leftarg2 = new ASTConstant(JJTCONSTANT);
			leftarg2.setValue(dim);
			jjtree.pushNode(leftarg2);
		} <LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/         
	|
	LOOKAHEAD(Identifier() <PIPE> <LSQ> RealConstant() <RSQ> UnaryExpression())/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	( identString = Identifier()			// added by LM: APL-style pair-scan-with-dim operator
	  <PIPE> <LSQ> dim = RealConstant() <RSQ> 
		{
			reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
			jjtn003.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("|");
			jjtree.pushNode(leftarg);
			ASTConstant leftarg2 = new ASTConstant(JJTCONSTANT);
			leftarg2.setValue(dim);
			jjtree.pushNode(leftarg2);
		} <LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/         
	|
	LOOKAHEAD(Identifier() <BDIV> <LSQ> RealConstant() <RSQ> UnaryExpression())/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*/
	( identString = Identifier()			// added by LM: APL-style scan-with-dim operator
	  <BDIV> <LSQ> dim = RealConstant() <RSQ> 
		{
			reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
			jjtn004.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
			ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
			leftarg.setValue("\\");
			jjtree.pushNode(leftarg);
			ASTConstant leftarg2 = new ASTConstant(JJTCONSTANT);
			leftarg2.setValue(dim);
			jjtree.pushNode(leftarg2);
		} <LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte004) {
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte004 instanceof RuntimeException) {
            throw (RuntimeException)jjte004;
          }
          if (jjte004 instanceof ParseException) {
            throw (ParseException)jjte004;
          }
          throw (Error)jjte004;
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004, true);
          }
        }
/*@egen*/         
	|
	LOOKAHEAD(20)/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn005 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*/							// added by LM: APL-style reduction operator
	( identString = Identifier()
		{
			if(jep.funTab.containsKey(identString)) {
				reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
				jjtn005.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
				ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
				leftarg.setValue("/");
				jjtree.pushNode(leftarg);
			} else {
				addToErrorList(JEP.getMessage("JEP.ERR.UNREC_FUN") + ": \"" + identString + "\"");
			}
		}
		<DIV> <LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte005) {
          if (jjtc005) {
            jjtree.clearNodeScope(jjtn005);
            jjtc005 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte005 instanceof RuntimeException) {
            throw (RuntimeException)jjte005;
          }
          if (jjte005 instanceof ParseException) {
            throw (ParseException)jjte005;
          }
          throw (Error)jjte005;
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005, true);
          }
        }
/*@egen*/         
	|
	LOOKAHEAD(20)/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn006 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*/							// added by LM: APL-style pair-scan operator
	( identString = Identifier()
		{
			if(jep.funTab.containsKey(identString)) {
				reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
				jjtn006.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
				ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
				leftarg.setValue("|");
				jjtree.pushNode(leftarg);
			} else {
				addToErrorList(JEP.getMessage("JEP.ERR.UNREC_FUN") + ": \"" + identString + "\"");
			}
		}
		<PIPE> <LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            throw (RuntimeException)jjte006;
          }
          if (jjte006 instanceof ParseException) {
            throw (ParseException)jjte006;
          }
          throw (Error)jjte006;
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/         
	|
	LOOKAHEAD(20)/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn007 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*/							// added by LM: APL-style scan operator
	( identString = Identifier()
		{
			if(jep.funTab.containsKey(identString)) {
				reqArguments = ((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
				jjtn007.setFunction(identString, (PostfixMathCommandI)jep.funTab.get(identString));
				ASTConstant leftarg = new ASTConstant(JJTCONSTANT);
				leftarg.setValue("\\");
				jjtree.pushNode(leftarg);
			} else {
				addToErrorList(JEP.getMessage("JEP.ERR.UNREC_FUN") + ": \"" + identString + "\"");
			}
		}
		<BDIV> <LRND> ArgumentList(reqArguments, identString) <RRND>
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte007) {
          if (jjtc007) {
            jjtree.clearNodeScope(jjtn007);
            jjtc007 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte007 instanceof RuntimeException) {
            throw (RuntimeException)jjte007;
          }
          if (jjte007 instanceof ParseException) {
            throw (ParseException)jjte007;
          }
          throw (Error)jjte007;
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
          }
        }
/*@egen*/         
}


void ArgumentList(int reqArguments, String functionName) : { int count = 0; String errorStr = ""; }
{
	[
		Expression()
			{ count++; }
		( <COMMA> Expression()
			{ count++; }
		)*
	]
    	{
			if(reqArguments != count && reqArguments != -1) {
				errorStr = JEP.getMessage("JEP.ERR.FUN") + " \"" + functionName + "\" " + JEP.getMessage("JEP.ERR.REQ") + " " + reqArguments + " ";  // modified by lm
				if(reqArguments != 1) errorStr += JEP.getMessage("JEP.ERR.PARAMS");
				else errorStr += JEP.getMessage("JEP.ERR.PARAM");
				addToErrorList(errorStr);
			}
		}
}


String Identifier() : { Token t; }
{
	( t=<IDENTIFIER1> | t=<IDENTIFIER2> )
		{ return t.image; }
}


void AnyConstant()           : {/*@bgen(jjtree) Constant */
                                 ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; Object value; }
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	t=<STRING_LITERAL>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			// strip away double quotes at end of string
			String temp = (t.image).substring(1,t.image.length()-1);
			// replace escape characters
			temp = replaceEscape(temp);
			jjtn000.setValue(temp);
		}
	|
	value = RealConstant()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ jjtn000.setValue(value); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


Object RealConstant() : { Token t; Object value; }
{
	( t=<INTEGER_LITERAL> | t=<FLOATING_POINT_LITERAL> )
		{
			try {
				value = jep.getNumberFactory().createNumber(t.image);
			} catch (Exception e) {
				value = null;
				addToErrorList(JEP.getMessage("JEP.ERR.PARSE") + " \"" + t.image + "\""); // modified by lm
			}
			return value;
		}
}
