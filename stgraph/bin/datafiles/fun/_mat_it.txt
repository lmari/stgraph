#<h2>STGraph - Funzioni matematiche</h2>
acos = <a href="fun/acos_it.txt">acos(x)</a>: <i>[x:A]</i> arcocoseno di <code>x</code>
asin = <a href="fun/asin_it.txt">asin(x)</a>: <i>[x:A]</i> arcoseno di <code>x</code>
atan = <a href="fun/atan_it.txt">atan(x)</a>: <i>[x:A]</i> arcotangente di <code>x</code>
bline = <a href="fun/bline_it.txt">bline(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> il valore <code>y</code> corrispondente a <code>x</code> sul segmento da <code>(vx[0],vy[0])</code> a <code>(vx[1],vy[1])</code>, e costante altrove
cos = <a href="fun/cos_it.txt">cos(x)</a>: <i>[x:A]</i> coseno di <code>x</code>
deg2rad = <a href="fun/deg2rad_it.txt">deg2rad(x)</a>: <i>[x:A]</i> valore di <code>x</code> convertito da gradi a radianti
exp = <a href="fun/exp_it.txt">exp(x)</a>: <i>[x:A]</i> esponenziale di <code>x</code> (<code>e</code> elevato alla potenza <code>x</code>)
FFT = <a href="fun/FFT_it.txt">FFT(x,s)</a>: <i>[x:V,M; s:S]</i> se <code>s==1</code>, trasformata veloce di Fourier del vettore <code>x</code>; se <code>s==2</code>, antitrasformata veloce di Fourier della matrice <code>x</code>
int = <a href="fun/int_it.txt">int(x)</a>: <i>[x:A]</i> parte intera di <code>x</code>
integral = <a href="fun/integral_it.txt">integral(x)</a>: <i>[x:A]</i> nelle transizioni di stato dei nodi di stato, somma iterativa di <code>x</code>, sulla base dell'algoritmo di integrazione scelto
line = <a href="fun/line_it.txt">line(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> valore <code>y</code> corrispondente a <code>x</code> sulla linea retta per i punti <code>vx[0],vy[0]</code> e <code>vx[1],vy[1]</code>
log = <a href="fun/log-1_it.txt">log(x)</a>: <i>[x:A]</i> logaritmo naturale di <code>x</code> <br> <a href="fun/log-2_it.txt">log(x,y)</a>: <i>[x,y:A]</i> logaritmo di <code>x</code> in base <code>y</code>
max = <a href="fun/max_it.txt">max(x,y)</a>: <i>[x,y:A]</i> massimo tra <code>x</code> e <code>y</code>
min = <a href="fun/min_it.txt">min(x,y)</a>: <i>[x,y:A]</i> minimo tra <code>x</code> e <code>y</code>
mod = <a href="fun/mod_it.txt">mod(x,y)</a>: <i>[x,y:A]</i> <code>x</code> modulo <code>y</code>
pline = <a href="fun/pline_it.txt">pline(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> valore <code>y</code> corrispondente a <code>x</code> sulla polinomiale i cui vertici sono nei vettori <code>vx</code> e <code>vy</code>
rad2deg = <a href="fun/rad2deg_it.txt">rad2deg(x)</a>: <i>[x:A]</i> valore di <code>x</code> convertito da radianti a gradi
round = <a href="fun/round_it.txt">round(x,y)</a>: <i>[x,y:A]</i> <code>x</code> arrotondato a <code>y</code> decimali
sigmoid = <a href="fun/sigmoid_it.txt">sigmoid(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> valore <code>y</code> corrispondente a <code>x</code> sulla sigmoide controllata dai punti <code>vx[0],vy[0]</code> e <code>vx[1],vy[1]</code>
sign = <a href="fun/sign_it.txt">sign(x)</a>: <i>[x:A]</i> segno di <code>x</code>, cioe' <code>1</code> se <code>x > 0</code>, <code>-1</code> se <code>x < 0</code>, <code>0</code> se <code>x == 0</code>
sin = <a href="fun/sin_it.txt">sin(x)</a>: <i>[x:A]</i> seno di <code>x</code>
spline = <a href="fun/spline_it.txt">spline(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> valore <code>y</code> corrispondente a <code>x</code> sulla spline i cui nodi sono nei vettori <code>vx</code> e <code>vy</code>
sqrt = <a href="fun/sqrt_it.txt">sqrt(x)</a>: <i>[x:A]</i> radice quadrata di <code>x</code>
tan = <a href="fun/tan_it.txt">tan(x)</a>: <i>[x:A]</i> tangente di <code>x</code>
wrap = <a href="fun/wrap_it.txt">wrap(x,y)</a>: <i>[x,y:A]</i> <code>x</code> modulo <code>y</code> con gestione dei valori negativi



<hr>
<a href="functions_en.properties">List of functions</a>
