#<h2>STGraph - Mathematical functions</h2>
acos = <a href="fun/acos_en.txt">acos(x)</a>: <i>[x:A]</i> arccosine of <code>x</code>
asin = <a href="fun/asin_en.txt">asin(x)</a>: <i>[x:A]</i> arcsine of <code>x</code>
atan = <a href="fun/atan_en.txt">atan(x)</a>: <i>[x:A]</i> arctangent of <code>x</code>
bline = <a href="fun/bline_en.txt">bline(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> the <code>y</code> value corresponding to <code>x</code> over the segment from <code>(vx[0],vy[0])</code> to <code>(vx[1],vy[1])</code>, and constant elsewhere
cos = <a href="fun/cos_en.txt">cos(x)</a>: <i>[x:A]</i> cosine of <code>x</code>
deg2rad = <a href="fun/deg2rad_en.txt">deg2rad(x)</a>: <i>[x:A]</i> value of <code>x</code> converted from degrees to radians
exp = <a href="fun/exp_en.txt">exp(x)</a>: <i>[x:A]</i> exponential of <code>x</code>, i.e., <code>e</code> to the power of <code>x</code>
FFT = <a href="fun/FFT_en.txt">FFT(x,s)</a>: <i>[x:V,M; s:S]</i> if <code>s==1</code>, fast Fourier transform of the vector <code>x</code>; if <code>s==2</code>, inverse fast Fourier transform of the matrix <code>x</code>
int = <a href="fun/int_en.txt">int(x)</a>: <i>[x:A]</i> integer part of <code>x</code>
integral = <a href="fun/integral_en.txt">integral(x)</a>: <i>[x:A]</i> in state transitions of state nodes, iterative sum of <code>x</code>, according to the chosen integration algorithm
line = <a href="fun/line_en.txt">line(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> the <code>y</code> value corresponding to <code>x</code> over the straight line crossing the points <code>vx[0],vy[0]</code> and <code>vx[1],vy[1]</code>
log = <a href="fun/log-1_en.txt">log(x)</a>: <i>[x:A]</i> natural logarithm of <code>x</code> <br> <a href="fun/log-2_en.txt">log(x,y)</a>: <i>[x,y:A]</i> logarithm of <code>x</code> to the base <code>y</code>
max = <a href="fun/max_en.txt">max(x,y)</a>: <i>[x,y:A]</i> maximum between <code>x</code> and <code>y</code>
min = <a href="fun/min_en.txt">min(x,y)</a>: <i>[x,y:A]</i> minimum between <code>x</code> and <code>y</code>
mod = <a href="fun/mod_en.txt">mod(x,y)</a>: <i>[x,y:A]</i> <code>x</code> modulus <code>y</code>
pline = <a href="fun/pline_en.txt">pline(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> the <code>y</code> value corresponding to <code>x</code> over the polyline whose vertices are in the vectors <code>vx</code> and <code>vy</code>
rad2deg = <a href="fun/rad2deg_en.txt">rad2deg(x)</a>: <i>[x:A]</i> value of <code>x</code> converted from radians to degrees
round = <a href="fun/round_en.txt">round(x,y)</a>: <i>[x,y:A]</i> <code>x</code> rounded to <code>y</code> decimals
sigmoid = <a href="fun/sigmoid_en.txt">sigmoid(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> the <code>y</code> value corresponding to <code>x</code> over the sigmoid controlled by the points <code>vx[0],vy[0]</code> and <code>vx[1],vy[1]</code>
sign = <a href="fun/sign_en.txt">sign(x)</a>: <i>[x:A]</i> sign of <code>x</code>, i.e., <code>1</code> if <code>x > 0</code>, <code>-1</code> if <code>x < 0</code>, <code>0</code> if <code>x == 0</code>
sin = <a href="fun/sin_en.txt">sin(x)</a>: <i>[x:A]</i> sine of <code>x</code>
spline = <a href="fun/spline_en.txt">spline(vx,vy,x)</a>: <i>[vx,vy:V, x:A]</i> the <code>y</code> value corresponding to <code>x</code> over the spline whose node points are in the vectors <code>vx</code> and <code>vy</code>
sqrt = <a href="fun/sqrt_en.txt">sqrt(x)</a>: <i>[x:A]</i> square root of <code>x</code>
tan = <a href="fun/tan_en.txt">tan(x)</a>: <i>[x:A]</i> tangent of <code>x</code>
wrap = <a href="fun/wrap_en.txt">wrap(x,y)</a>: <i>[x,y:A]</i> <code>x</code> modulus <code>y</code> also dealing with negative values



<hr>
<a href="functions_en.properties">List of functions</a>
